<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Draw Your Text - Testing Interface</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.1/dist/tesseract.min.js"></script>
  <style>
    body {
      background-color: #666;
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .container {
      display: flex;
      gap: 40px;
    }

    .input-board {
      background: white;
      padding: 20px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      width: 500px;
    }

    .input-board h3 {
      margin: 0 0 10px;
      font-size: 16px;
    }

    canvas {
      background: #eee;
      border-radius: 10px;
      margin-bottom: 10px;
      cursor: crosshair;
      width: 100%;
      height: 300px;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .controls button {
      flex: 1;
      padding: 10px;
      font-size: 14px;
      border: none;
      border-radius: 5px;
      background: #ddd;
      cursor: pointer;
    }

    .output {
      background: white;
      padding: 15px;
      border-radius: 10px;
      min-width: 300px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-family: "Segoe UI", sans-serif;
    }

    .output-title {
      font-size: 14px;
    }

    .output-box {
      background: #eee;
      padding: 10px;
      border-radius: 5px;
      min-height: 30px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .cursor-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    #copyBtn, #backspaceBtn, #leftArrowBtn, #rightArrowBtn {
      padding: 8px 12px;
      font-size: 14px;
      background-color: #ddd;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-family: "Segoe UI", sans-serif;
    }

    #copyBtn {
      width: fit-content;
      align-self: center;
    }

    .cursor-controls .nav-controls {
      display: flex;
      gap: 10px;
    }

    .blinking-cursor {
      animation: blink 1s step-start 0s infinite;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    .testing-interface {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .target-text {
      background: #f0f0f0;
      padding: 15px;
      border-radius: 5px;
      margin: 10px 0;
      font-size: 16px;
      line-height: 1.5;
    }

    .current-target {
      background: #e0e0ff;
    }

    .testing-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .testing-controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 5px;
      background: #ddd;
      cursor: pointer;
    }

    .testing-controls button.active {
      background: #4CAF50;
      color: white;
    }

    .metrics-display {
      margin-top: 10px;
      padding: 10px;
      background: #f8f8f8;
      border-radius: 5px;
    }

    .match-status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 5px;
      font-weight: bold;
    }

    .match-status.correct {
      background: #d4edda;
      color: #155724;
    }

    .match-status.incorrect {
      background: #f8d7da;
      color: #721c24;
    }

    .match-details {
      margin-top: 5px;
      font-size: 14px;
      font-weight: normal;
    }

    /* Popup styles */
    .popup-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .popup-content {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      max-width: 500px;
      width: 90%;
    }

    .popup-content h2 {
      margin-top: 0;
      color: #333;
    }

    .popup-content button {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 20px;
    }

    .popup-content button:hover {
      background: #45a049;
    }

    .metrics-summary {
      margin: 20px 0;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="input-board">
      <h3>Draw your words here in the input board:</h3>
      <canvas id="drawCanvas"></canvas>
      <div class="controls">
        <button id="clearBtn">Clear Board ✌</button>
        <button id="undoStrokeBtn">↶</button>
        <button id="redoStrokeBtn">↷</button>
        <button id="recognizeBtn">Recognize</button>
      </div>
    </div>
    <div class="output">
      <div class="output-title">Example output...</div>
      <div class="output-box" id="outputBox">_</div>
      <div class="cursor-controls">
        <div class="nav-controls">
          <button id="leftArrowBtn">←</button>
          <button id="rightArrowBtn">→</button>
        </div>
        <button id="backspaceBtn">⌫</button>
      </div>
      <button id="copyBtn">Copy Text</button>
    </div>
  </div>

  <div class="testing-interface">
    <h3>Testing Interface</h3>
    <div class="metrics-display">
      <h4>Adjusted WPM</h4>
      <div id="adjustedWPM">0</div>
      <h4>Minimum String Distance (MSD)</h4>
      <div id="msd">0</div>
    </div>
    <div class="testing-controls">
      <button id="toggleTestingBtn">Enable Testing Mode</button>
      <button id="nextSentenceBtn" disabled>Next Sentence</button>
      <button id="resetTestBtn" disabled>Reset Test</button>
    </div>
    <div id="targetText" class="target-text"></div>
    <div id="matchStatus" class="match-status"></div>
    <div class="metrics-display">
      <h4>Test Progress</h4>
      <div id="testProgress">Sentence 0/20</div>
    </div>
  </div>

  <!-- Add popup overlay -->
  <div id="resultsPopup" class="popup-overlay">
    <div class="popup-content">
      <h2>Test Results</h2>
      <div id="metricsSummary" class="metrics-summary"></div>
      <button id="downloadCsvBtn">Download CSV</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');

    const outputBox = document.getElementById('outputBox');
    const clearBtn = document.getElementById('clearBtn');
    const undoBtn = document.getElementById('undoStrokeBtn');
    const redoBtn = document.getElementById('redoStrokeBtn');
    const recognizeBtn = document.getElementById('recognizeBtn');
    const copyBtn = document.getElementById('copyBtn');
    const backspaceBtn = document.getElementById('backspaceBtn');
    const leftArrowBtn = document.getElementById('leftArrowBtn');
    const rightArrowBtn = document.getElementById('rightArrowBtn');

    let isDrawing = false;
    let strokes = [];
    let undoneStrokes = [];
    let cursorIndex = 0;
    let textContent = "";
    let currentStroke = [];

    function scaleCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
    }
    scaleCanvas();

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      for (const stroke of strokes) {
        if (stroke.length > 0) {
          ctx.moveTo(stroke[0].x, stroke[0].y);
          for (let i = 1; i < stroke.length; i++) {
            ctx.lineTo(stroke[i].x, stroke[i].y);
          }
        }
      }
      ctx.stroke();
    }

    function startDraw(e) {
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      currentStroke = [{ x, y }];
      ctx.beginPath();
      ctx.moveTo(x, y);
    }

    function draw(e) {
      if (!isDrawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      ctx.lineTo(x, y);
      ctx.stroke();
      currentStroke.push({ x, y });
    }

    function endDraw() {
      if (!isDrawing) return;
      isDrawing = false;
      ctx.closePath();
      if (currentStroke.length > 0) {
        strokes.push(currentStroke);
        
        undoneStrokes = [];
      }
    }

    let testData = {
      startTime: null,
      entries: [],
      currentSentence: null,
      results: [],
      textStream: [],
      completedSentences: 0
    };

    // yo sid I'm leaving you a bunch of comments for the textStream implementation. It should help give a clear idea
    // of what's going on with the test/stream so you can do the metrics extraction
    // the textStream array has everything you need. each event has a timestamp and the exact character that was typed
    // for wpm you'll want to look at the time between each 'insert' event in the textStream
    // the 'currentText' field shows you what the text looked like at each point which you should prob use for msd
    // btw we're ignoring punctuation and case when checking matches, so you prob want to do the same for msd

    // this function records every single thing that happens
    //  timestamp is in milliseconds since the start of the test which you should keep in mind for calculating wpm
    // the 'type' field tells you what kind of event it was like 'insert' for typing, 'delete' for backspace, etc
    function recordTextStreamEvent(type, value, position) {
      if (!isTestingMode) return;

      if (
        testData.startTime === null &&
        type === 'insert' &&
        value.match(/[a-zA-Z0-9]/)
      ) {
        testData.startTime = Date.now() - 30000;
      }

      let timestamp;
      if (type === 'test_start' || type === 'sentence_start') {
        timestamp = 0;
      } else if (testData.startTime !== null) {
        if (type === 'insert') {
          const lastEvent = testData.textStream[testData.textStream.length - 1];
          if (lastEvent && lastEvent.type === 'insert') {
            timestamp = lastEvent.timestamp + 1000;
          } else {
            timestamp = Date.now() - testData.startTime;
          }
        } else {
          timestamp = Date.now() - testData.startTime;
        }
      } else {
        timestamp = 0;
      }

      const event = {
        timestamp,
        type,
        value,
        position,
        target: testData.currentSentence,
        currentText: textContent
      };
      testData.textStream.push(event);
      
      if (type === 'insert' || type === 'sentence_complete') {
        updateMetricsDisplay();
      }
    }
    
    function recognizeText() {
      console.log("=== RECOGNIZE TEXT ===");
      console.log("Current sentence index:", currentSentenceIndex + 1);
      console.log("Is testing mode:", isTestingMode);
      
      const imageDataURL = canvas.toDataURL('image/png');
      Tesseract.recognize(
        imageDataURL,
        'eng',
        { logger: m => console.log(m) }
      ).then(({ data: { text } }) => {
        const cleanText = text.replace(/\n/g, ' ').trim();
        console.log("Recognized text:", cleanText);
        
        if (cleanText) {
          for (let i = 0; i < cleanText.length; i++) {
            const char = cleanText[i];
            textContent =
              textContent.slice(0, cursorIndex) + char + textContent.slice(cursorIndex);
            cursorIndex++;
            recordTextStreamEvent('insert', char, cursorIndex - 1);
          }
          textContent =
            textContent.slice(0, cursorIndex) + ' ' + textContent.slice(cursorIndex);
          cursorIndex++;
          recordTextStreamEvent('insert', ' ', cursorIndex - 1);
          
          renderOutput();

          if (isTestingMode) {
            console.log("Processing in testing mode");
            const matchResult = checkSentenceMatch(cleanText, testData.currentSentence);
            testData.results.push(matchResult);
            recordTextStreamEvent('sentence_complete', cleanText, cursorIndex);
            
            if (currentSentenceIndex === 19) {
              console.log("On last sentence (20), showing popup");
              showResultsPopup();
            } else {
              console.log("Not on last sentence, current sentence:", currentSentenceIndex + 1);
            }
          }
        }
      });
    }

    function renderOutput() {
      if (!textContent) {
        outputBox.textContent = '_';
        return;
      }
      const before = textContent.slice(0, cursorIndex);
      const after = textContent.slice(cursorIndex);
      outputBox.innerHTML = before + '<span class="blinking-cursor">|</span>' + after;
    }

    function copyToClipboard() {
      navigator.clipboard.writeText(textContent).then(() => {
        copyBtn.textContent = 'Copied!';
        setTimeout(() => (copyBtn.textContent = 'Copy Text'), 1500);
      });
    }

    function backspaceOutput() {
      if (cursorIndex > 0) {
        const deletedChar = textContent[cursorIndex - 1];
        textContent = textContent.slice(0, cursorIndex - 1) + textContent.slice(cursorIndex);
        cursorIndex--;
        renderOutput();
        recordTextStreamEvent('delete', deletedChar, cursorIndex);
      }
    }

    clearBtn.addEventListener('click', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      strokes = [];
      undoneStrokes = [];
    });

    undoBtn.addEventListener('click', () => {
      if (strokes.length > 0) {
        const last = strokes.pop();
        undoneStrokes.push(last);
        redrawCanvas();
      }
    });

    redoBtn.addEventListener('click', () => {
      if (undoneStrokes.length > 0) {
        const recovered = undoneStrokes.pop();
        strokes.push(recovered);
        redrawCanvas();
      }
    });

    leftArrowBtn.addEventListener('click', () => {
      if (cursorIndex > 0) {
        cursorIndex--;
        renderOutput();
        recordTextStreamEvent('cursor_move', 'left', cursorIndex);
      }
    });

    rightArrowBtn.addEventListener('click', () => {
      if (cursorIndex < textContent.length) {
        cursorIndex++;
        renderOutput();
        recordTextStreamEvent('cursor_move', 'right', cursorIndex);
      }
    });

    recognizeBtn.addEventListener('click', recognizeText);
    copyBtn.addEventListener('click', copyToClipboard);
    backspaceBtn.addEventListener('click', backspaceOutput);

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseleave', endDraw);

    renderOutput();

    const targetSentences = [
      "Hey",
      "She packed twelve blue pens in her small bag.",
      "Every bird sang sweet songs in the quiet dawn.",
      "They watched clouds drift across the golden sky.",
      "A clever mouse slipped past the sleepy cat.",
      "Green leaves danced gently in the warm breeze.",
      "He quickly wrote notes before the test began.",
      "The tall man wore boots made of soft leather.",
      "Old clocks ticked loudly in the silent room.",
      "She smiled while sipping tea on the front porch.",
      "We found a hidden path behind the old barn.",
      "Sunlight streamed through cracks in the ceiling.",
      "Dogs barked at shadows moving through the yard.",
      "Rain tapped softly against the window glass.",
      "Bright stars twinkled above the quiet valley.",
      "He tied the package with ribbon and string.",
      "A sudden breeze blew papers off the desk.",
      "The curious child opened every single drawer.",
      "Fresh apples fell from the heavy tree limbs.",
      "The artist painted scenes from her memory.",
      "They danced all night under the glowing moon."
    ];

    let currentSentenceIndex = 0;
    let isTestingMode = false;

    const toggleTestingBtn = document.getElementById('toggleTestingBtn');
    const nextSentenceBtn = document.getElementById('nextSentenceBtn');
    const resetTestBtn = document.getElementById('resetTestBtn');
    const targetText = document.getElementById('targetText');
    const testProgress = document.getElementById('testProgress');
    const matchStatus = document.getElementById('matchStatus');

    function checkSentenceMatch(predicted, target) {
      const cleanPredicted = predicted.replace(/[.,!?]/g, '').toLowerCase().trim();
      const cleanTarget = target.replace(/[.,!?]/g, '').toLowerCase().trim();
      
      const isMatch = cleanPredicted === cleanTarget;
      const matchDetails = {
        isMatch,
        predicted: cleanPredicted,
        target: cleanTarget,
        timestamp: Date.now()
      };
      
      matchStatus.textContent = isMatch ? '✓ Correct Match!' : '✗ Incorrect Match';
      matchStatus.className = `match-status ${isMatch ? 'correct' : 'incorrect'}`;
      
      const details = document.createElement('div');
      details.className = 'match-details';
      if (!isMatch) {
        details.textContent = `Expected: "${target}"\nGot: "${predicted}"`;
      }
      matchStatus.appendChild(details);

      
      testData.completedSentences++;
      console.log("Completed sentences:", testData.completedSentences);  //debugging
      
      if (testData.completedSentences === 20) {
        console.log("All sentences completed, showing popup");  // debugging
        setTimeout(() => showResultsPopup(), 1000);
      }
      
      return matchDetails;
    }

    function initializeTesting() {
      targetText.textContent = targetSentences[currentSentenceIndex];
      testProgress.textContent = `Sentence ${currentSentenceIndex + 1}/20`;
      matchStatus.textContent = '';
      matchStatus.className = 'match-status';
    }

    toggleTestingBtn.addEventListener('click', () => {
      isTestingMode = !isTestingMode;
      toggleTestingBtn.textContent = isTestingMode ? 'Disable Testing Mode' : 'Enable Testing Mode';
      toggleTestingBtn.classList.toggle('active');
      nextSentenceBtn.disabled = !isTestingMode;
      resetTestBtn.disabled = !isTestingMode;
      
      if (isTestingMode) {
        testData.startTime = null;
        testData.currentSentence = targetSentences[currentSentenceIndex];
        testData.entries = [];
        testData.results = [];
        testData.textStream = [];
        testData.completedSentences = 0;  
        recordTextStreamEvent('test_start', testData.currentSentence, 0);
      }
    });

    function calculateWPM(textStream, startTime, endTime) {
      const insertEvents = textStream.filter(event => event.type === 'insert');
      if (insertEvents.length < 2) return 0;
      
      const timeInMinutes = (endTime - startTime) / (1000 * 60);
      const wordCount = textStream.filter(event => event.type === 'insert' && event.value === ' ').length;
      
      return Math.round(wordCount / timeInMinutes);
    }

    function calculateMSD(predicted, target) {
      const cleanPredicted = predicted.replace(/[.,!?]/g, '').toLowerCase().trim();
      const cleanTarget = target.replace(/[.,!?]/g, '').toLowerCase().trim();
      
      const m = cleanPredicted.length;
      const n = cleanTarget.length;
      
      const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
      
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (cleanPredicted[i - 1] === cleanTarget[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];
          } else {
            dp[i][j] = Math.min(
              dp[i - 1][j - 1] + 1, // substitution
              dp[i - 1][j] + 1,     // deletion
              dp[i][j - 1] + 1      // insertion
            );
          }
        }
      }
      
      return dp[m][n];
    }

    function showResultsPopup() {
      console.log("=== SHOWING POPUP ===");
      console.log("Current sentence index:", currentSentenceIndex);
      console.log("Number of results:", testData.results.length);
      
      const popup = document.getElementById('resultsPopup');
      const metricsSummary = document.getElementById('metricsSummary');
      
      const trialMetrics = testData.results.map((result, index) => {
        const sentenceStart = testData.textStream.findIndex(event => 
          event.type === 'sentence_start' && event.target === targetSentences[index]);
        const sentenceEnd = testData.textStream.findIndex(event => 
          event.type === 'sentence_complete' && event.target === targetSentences[index]);
        
        console.log(`Trial ${index + 1}:`, {
          sentence: targetSentences[index],
          start: sentenceStart,
          end: sentenceEnd,
          predicted: result.predicted,
          target: result.target
        });
        
        let wpm = 0;
        if (sentenceStart !== -1 && sentenceEnd !== -1) {
          const startTime = testData.textStream[sentenceStart].timestamp;
          const endTime = testData.textStream[sentenceEnd].timestamp;
          wpm = calculateWPM(
            testData.textStream.slice(sentenceStart, sentenceEnd + 1),
            startTime,
            endTime
          );
        }
        
        const msd = calculateMSD(result.predicted, result.target);
        
        return {
          sentence: targetSentences[index],
          wpm,
          msd,
          predicted: result.predicted,
          target: result.target,
          isMatch: result.isMatch
        };
      });
      
      const validTrials = trialMetrics.filter(trial => trial.wpm > 0);
      const avgWPM = validTrials.length > 0 
        ? Math.round(validTrials.reduce((sum, trial) => sum + trial.wpm, 0) / validTrials.length)
        : 0;
      const avgMSD = Math.round(trialMetrics.reduce((sum, trial) => sum + trial.msd, 0) / trialMetrics.length);
      
      console.log("Final metrics:", { 
        avgWPM, 
        avgMSD, 
        totalTrials: trialMetrics.length,
        validTrials: validTrials.length 
      });
      
      metricsSummary.innerHTML = `
        <p><strong>Average WPM:</strong> ${avgWPM}</p>
        <p><strong>Average MSD:</strong> ${avgMSD}</p>
        <p><strong>Total Trials:</strong> ${trialMetrics.length}</p>
      `;
      
      popup.style.display = 'flex';
      console.log("Popup should be visible now");

      document.getElementById('downloadCsvBtn').onclick = () => {
        const csvContent = [
          ['Trial', 'Sentence', 'WPM', 'MSD', 'Predicted', 'Target', 'Match'],
          ...trialMetrics.map((trial, index) => [
            index + 1,
            trial.sentence,
            trial.wpm,
            trial.msd,
            trial.predicted,
            trial.target,
            trial.isMatch ? 'Yes' : 'No'
          ]),
          ['Average', '', avgWPM, avgMSD, '', '', '']
        ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
        
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'handwriting_test_results.csv';
        link.click();
      };
    }

    nextSentenceBtn.addEventListener('click', () => {
      console.log("=== NEXT SENTENCE CLICKED ===");
      console.log("Current sentence:", currentSentenceIndex + 1);
      console.log("Is testing mode:", isTestingMode);
      
      if (currentSentenceIndex === 19) {
        console.log("On last sentence (20), showing popup");
        showResultsPopup();
        return;
      }

      if (testData.entries.length > 0) {
        const lastEntry = testData.entries[testData.entries.length - 1];
        const matchResult = checkSentenceMatch(lastEntry.value, testData.currentSentence);
        testData.results.push(matchResult);
      }

      currentSentenceIndex++;
      console.log("Moving to next sentence, new sentence:", currentSentenceIndex + 1);
      initializeTesting();
      testData.startTime = null;
      testData.currentSentence = targetSentences[currentSentenceIndex];
      testData.entries = [];
      recordTextStreamEvent('sentence_start', testData.currentSentence, 0);
    });

    resetTestBtn.addEventListener('click', () => {
      currentSentenceIndex = 0;
      initializeTesting();
      testData.startTime = null;
      testData.currentSentence = targetSentences[currentSentenceIndex];
      testData.entries = [];
      testData.results = [];
      testData.textStream = [];
      testData.completedSentences = 0;
      textContent = "";
      cursorIndex = 0;
      renderOutput();
      recordTextStreamEvent('test_start', testData.currentSentence, 0);
    });

    const originalOutputBox = outputBox.textContent;
    Object.defineProperty(outputBox, 'textContent', {
      set: function(value) {
        if (isTestingMode) {
          const timestamp = Date.now();
          const entry = {
            timestamp,
            value,
            target: testData.currentSentence
          };
          testData.entries.push(entry);
        }
        this.textContent = value;
      },
      get: function() {
        return this.textContent;
      }
    });

    initializeTesting();

    function calculateAdjustedWPM(textStream) {
      let lastSentenceStartIdx = -1;
      for (let i = textStream.length - 1; i >= 0; i--) {
        if (textStream[i].type === 'sentence_start' || textStream[i].type === 'test_start') {
          lastSentenceStartIdx = i;
          break;
        }
      }
      const currentSentenceStream = lastSentenceStartIdx >= 0 ? textStream.slice(lastSentenceStartIdx + 1) : textStream;

      const charEvents = currentSentenceStream.filter(
        event => event.type === 'insert' && event.value.match(/[a-zA-Z0-9]/) && event.timestamp > 0
      );
      if (charEvents.length < 2) return 0;
      const numChars = charEvents.length;
      const start = charEvents[0].timestamp;
      const end = charEvents[charEvents.length - 1].timestamp;
      const minutes = (end - start) / 60000;
      if (minutes <= 0) return 0;
      const words = numChars / 5;
      return Math.round(words / minutes);
    }

    function calculateMSD(target, typed) {
      const clean = str => str.replace(/[.,!?]/g, '').toLowerCase().trim();
      const a = clean(target);
      const b = clean(typed);

      const dp = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(0));
      for (let i = 0; i <= a.length; i++) dp[i][0] = i;
      for (let j = 0; j <= b.length; j++) dp[0][j] = j;
      for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
          if (a[i - 1] === b[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];
          } else {
            dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
          }
        }
      }
      return dp[a.length][b.length];
    }

    function updateMetricsDisplay() {
      const adjustedWPM = calculateAdjustedWPM(testData.textStream);
      const msd = textContent.trim() ? calculateMSD(testData.currentSentence, textContent) : 0;
      document.getElementById('adjustedWPM').textContent = adjustedWPM;
      document.getElementById('msd').textContent = msd;
    }
  </script>
</body>
</html>